import funkin.play.character.AnimateAtlasCharacter;
import funkin.play.character.CharacterType;
import funkin.play.PlayState;
import flixel.FlxG;
import flixel.FlxSprite;
import flixel.group.FlxTypedSpriteGroup;
import animate.internal.elements.FlxSpriteElement;
import funkin.graphics.FunkinSprite;
import flixel.util.FlxSort;
import funkin.Conductor;
import funkin.util.SortUtil;
import Lambda;

class SserafimEunchaeCharacter extends AnimateAtlasCharacter
{
  var lipSyncSprite:SserafimLipSyncSprite;

  /**
   * A map of animation names to lip sync data.
   * This is so it gets offset properly!
   */
  final LIP_SYNC_OFFSETS:Map<String, LipSyncData> = [
    'idle' =>
    {
      offset: [43, 6],
      angle: -168
    },
    'singUP' =>
    {
      offset: [45, 10],
      angle: -166
    },
    'singRIGHT' =>
    {
      offset: [42, 5],
      angle: -166
    },
    'singDOWN' =>
    {
      offset: [41, 3],
      angle: -168
    },
    'singLEFT' =>
    {
      offset: [43, 6],
      angle: -169
    }
  ];

  function new()
  {
    super('sserafim-eunchae');
  }

  function onCreate(event:ScriptEvent):Void
  {
    super.onCreate(event);

    lipSyncSprite = new SserafimLipSyncSprite(0, 0);

    var element:FlxSpriteElement = new FlxSpriteElement(lipSyncSprite);
    element.active = false; // We disable the element here so we can control when it updates.

    for (frame in this.getFramesWithKeyword("mouth default"))
    {
      frame.add(element);
    }
  }

  override public function playAnimation(name:String, restart:Bool, ignoreOther:Bool):Void
  {
    super.playAnimation(name, restart, ignoreOther);

    if (LIP_SYNC_OFFSETS.exists(name) && lipSyncSprite != null)
    {
      var data:LipSyncData = LIP_SYNC_OFFSETS.get(name);

      lipSyncSprite.offset.set(data.offset[0], data.offset[1]);
      lipSyncSprite.angle = data.angle;
    }
  }

  override function update(elapsed:Float):Void
  {
    super.update(elapsed);
    lipSyncSprite.update(elapsed);

    lipSyncSprite.shouldSing = this.characterType == CharacterType.BF;

    synchronizeShader();
  }

  var currentShader = null;

  function synchronizeShader():Void
  {
    if (currentShader == this.shader) return;

    currentShader = this.shader;

    lipSyncSprite.shader = currentShader;

    trace("Synchronized shader between children!");
  }

  function hideDefaultMouth():Void
  {
    var symbolItem:SymbolItem = this.library.getSymbol('mouth default');
    var layer:Layer = symbolItem.timeline.getLayer(0);

    layer.forEachFrame((frame) -> {
      frame.forEachElement((element) -> {
        element.visible = false;
      });
    });
  }
}
